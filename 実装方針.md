# 実装方針諸々

1. kmeans = new_kemans()という呼び出し方
1. new_kemans内のハイパラチェックと、fit()時のハイパラチェックの二つ
1. moduleはなるべく細分化
1. 入出力の配列は２次元
    * X = (N, D), y = (N, 1)
1. モジュール名 = ファイル名
1. フォルダ構成
```
fortlearner/
├── base_estimator
│   └── mod_base_estimator.f90
├── kmeans
│   ├── mod_base_kmeans.f90
│   └── mod_kmeans.f90
└── utils
    ├── check
    │   ├── mod_check_all_rows_identical.f90
    │   ├── mod_check_allowed_options.f90
    │   ├── mod_check_array_shape.f90
    │   ├── mod_check_is_fitted.f90
    │   ├── mod_check_non_finite.f90
    │   ├── mod_check_range.f90
    │   ├── mod_check_relation.f90
    │   ├── mod_check_sign.f90
    │   └── mod_error_codes.f90
    ├── distance
    │   └── mod_euclidean_distance.f90
    ├── helpers
    │   ├── mod_character_helpers.f90
    │   └── mod_memory_helpers.f90
    ├── mod_clip.f90
    ├── mod_config.f90
    ├── mod_data_summary.f90
    ├── mod_datetime.f90
    ├── mod_error.f90
    ├── mod_is_finite.f90
    ├── mod_is_zero.f90
    ├── mod_kinds.f90
    ├── mod_program_limits.f90
    ├── mod_timer.f90
    ├── random
    │   ├── mod_random_int.f90
    │   ├── mod_random_permutation.f90
    │   ├── mod_random_seed.f90
    │   └── mod_weighted_reservoir.f90
    └── warn
        ├── mod_warn_array_size.f90
        ├── mod_warn_huge_value.f90
        ├── mod_warn_range.f90
        └── warn_cluster
            └── mod_warn_empty_cluster.f90

```

# FortLearner モデル Dump/Load ガイドライン

## 目的

モデル内部状態（ハイパラ・学習済みパラメータ）を **後方互換** を保ちながら安全に保存／復元する。

---

## ファイルフォーマット

| 項目      | 方針                                     |
| ------- | -------------------------------------- |
| アクセス    | `access='stream', form='unformatted'`  |
| エンディアン  | `convert='little_endian'` に固定          |
| 先頭メタデータ | `int32 :: version = 1`  *（将来機能拡張時に+1）* |
| 追加メンバー  | **親→子の順**で逐次書き込み                       |

---

## 継承層ごとの責務

| 型               | dump / load が扱うメンバー                                   | API 露出                                                 |
| --------------- | ----------------------------------------------------- | ------------------------------------------------------ |
| `BaseEstimator` | `random_state`                                        | `dump(unit)` / `load(unit)`                            |
| `BaseKMeans`    | `n_clusters`, `centroids(:,:)`<br>＋親の呼び出し             | 同上                                                     |
| `KMeans`        | *現在は追加メンバーなし* <br>将来: `tol`, など<br>＋`BaseKMeans` 呼び出し | `dump_file(filename)` / `load_file(filename)` ラッパーのみ公開 |

### 実装ルール

1. **親→子の順**に `call parent%dump(unit)` → 自分のメンバーを書き込む。
2. 読み込みも **同順序**。
3. 新メンバーを追加する時は、ラッパー関数（`dump_file` / `load_file`）に
   追記し、`version` を +1。
4. 旧バージョン読み込み時は `select case(version)` で分岐。

---

## 拡張手順（例: MiniBatchKMeans）

1. `type, extends(KMeans) :: MiniBatchKMeans` に新メンバー追加。
2. `dump_file_mbkmeans` / `load_file_mbkmeans` を実装。

   * まず `call dump_file_kmeans_base(self, unit)` で親を書き込み。
   * 続いて自分のメンバーを書き込み。
3. テスト:

   * **同一バージョン互換**: save→load→assert equal。
   * **旧バージョン互換**: 既存バイナリを読み込んで正しく復元できるか。

---

## テスト指針

* `@pytest.mark.parametrize` でバージョン毎にシリアライズ/デシリアライズを網羅。
* 大きな行列 (`>10^6` 要素) でもストリーム境界が正しいか確認。
* Python バインディング側: `np.fromfile(..., dtype='<f8', count=...)` で読めること。

---

## 注意点

* **可変長文字列・配列**は長さ/形状を先に `int32/int64` で書く。
* Fortran の列優先を Python で復元するときは `order='F'`。
* 圧縮は未サポート。必要なら `compress=1` フラグを追加（version +1）。

---

## 今後の議論ポイント

* マルチスレッド環境での I/O 排他制御。
* バイナリ互換性を保証する CI ジョブ追加（GitHub Actions に既存モデルをアーカイブしてテスト）。


## その他
   * 高速化
      * weighted_reservoir_single が重すぎる
      * sklearn-intelex を参考に高速化

